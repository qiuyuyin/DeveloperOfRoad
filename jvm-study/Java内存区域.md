# Java内存区域

## 运行时数据区域

<img src="Java内存区域.assets/image-20210720175844775.png" alt="image-20210720175844775" style="zoom:67%;" />

### 1.程序计数器

`程序计数器`在JVM中时线程独占的

,执行跳转,分支,循环,等条件.PC register,相当于汇编语言中的寄存器.

通过汇编语言可知,寄存器所占的空间一般都很小,所以不会出现存储值的溢出情况.

### 2.虚拟机栈

这个栈同样相当于汇编语言中的栈,JVM会为每个方法的执行中分配栈帧,以便于使用栈的空间.栈的主要功能是分配局部变量的空间,以及充当传递参数的区域以及存放返回值的区域.

Java虚拟机栈中会存在两种错误信息,分别是:**StackOverFlowError**和**OutOfMemoryError**

- **`StackOverFlowError`：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- **`OutOfMemoryError`：** Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

任何形式的栈结束都会存在两种条件:分别是出现异常和得到返回值

### 3.本地方法栈

由于在jdk1.1时期,java为了兼顾C和C++, 在java中引入了JNI的概念, 使用JNI可以直接调用C/C++的代码(函数), 而所使用的C语言函数调用则在本地方法栈中进行使用.

### 4.堆

堆是jvm中所占内存最大的一块

基本上所有的数组和类的实例的都是在堆上进行分配的

> 这个相对绝对是因为随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

堆也是GC垃圾回收的主要区域,由于垃圾回收一般采用分代算法来进行堆的细分,以便于更好的对堆中的资源进行优化和分析.



### 5.方法区

 `方法区` (Method Area),也就是后来的`元空间`.

> 由于在1.8之前,HotSpot虚拟机将方法区中的数据设置为永远存在于内存中,基本不会被GC回收. 所以被戏称为`永久代`.但是对于其他的虚拟机来说是并不存在永久代这个概念的.

### 6.运行时常量池

Class常量池中的内容如下图所示,在类加载过程中,jvm会将Class常量池中的内容加入到运行时常量池中,但是运行时常量池中的内容并不是固定不变的,而是可以在程序的加载过程中进行修改的,比如String中的intern()方法,可以将一个新的字符串加入到常量池中. 由于常量池是动态的,所以常量池也会出现OOM的问题.所以要避免过多的使用运行时常量池中的内容.

![img](Java内存区域.assets/20141010142338127)

### 7.直接内存

**直接内存并不是虚拟机运行内存的一部分**,也不是虚拟机内存定义规范中的内存区域,但是这部分的内存也会被频繁的使用,所以也会出现OOM等错误.

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制