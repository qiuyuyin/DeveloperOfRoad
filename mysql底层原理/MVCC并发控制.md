## MVCC并发控制

### 数据库并发场景

- 读-读
- 读-写
- 写-写

### MVCC的作用：

MVCC是用来解决读写冲突的无锁并发控制，也就是将事务和时间戳来进行关联，使得每次读操作不影响写操作，写操作不会阻塞读操作。在提升了数据库的读写性能时，解决了不可重复读，幻读，脏读和事务隔离问题，但是不能解决数据丢失问题。

> MVCC的实现原理：依赖记录中的 **3个隐式字段**，**undo日志** ，**Read View** 来实现的

### 隐式字段

**DB_ROW_ID** 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引

**DB_TRX_ID** 6byte, 最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID

**DB_ROLL_PTR** 7byte, 回滚指针，指向这条记录的上一个版本（存储于rollback segment里）

**DELETED_BIT** 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了

### undo日志

innodb中将用于回滚的日志称之为undo log。undo log是关于增删改相关的日志，而不会包含select中的日志。因为查找操作不会改变日志的版本号，而其他的三个操作会对版本号进行修改。

**Insert undo log** ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。

**Update undo log**：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。

**Delete undo log**：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。

- 删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。
- 为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。

### Read View（读视图）

read view 就是事务进行快照读时生成的一个读视图，在事务中执行读操作时，会根据现在存在的事务生成一个读视图，记录并维护当前存在的事务ID。

所以read view就是一个条件判断当前事务可以看见哪个版本的数据。

