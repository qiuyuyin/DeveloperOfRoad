## 数据库事务

**下面为本篇文章的大纲：**

![image-20210809114232591](innoDB中的事务.assets/image-20210809114232591.png)

### 1.事务特性

在事务中的特性可以简称为**ACID特性**，分别代表四个数据库事务所具有的特性。

实现事务必须要遵守 4 个特性，分别如下：

- **原子性（Atomicity）**：一个事务作为一个不可分割的最小单元。一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；
- **一致性（Consistency）**：数据库的完整性不会因为事务的执行而受到破坏，数据库总是从一个一致性的状态转换到另一个一致性的状态。比如在转账事务中，必须保证双方的总额是不会发生改变的，也称之为逻辑一致性。
- **隔离性（Isolation）**：一个事务在提交之前，对其他事务是不可见的，在一定情况下避免了脏读的发生。
- **持久性（Durability）**：一旦事务进行提交之后，对数据的修改就是永久的，即便系统故障也不会丢失。

> **那么数据库是如何实现这四个特性的呢？**

1. 对于`原子性（Atomicity）`和`一致性（Consistency）`，数据库可以通过底层的一个**undo log**机制来进行实现，主要是对事务的**rollback**操作来进行处理实现的
2. 对于数据的`持久性（Durability）`,数据库通过redo log来进行保证，原理是数据库引擎会先将修改的数据放到redo log中，而不会直接对数据库中的信息进行修改。在数据库出现故障时，虽然暂时没有对数据库进行修改，但是redo log会完整的保留下来，所以无需担心数据库中的数据出现变化。
3. `隔离性（Isolation）`是对于数据库事务最为重要的一个特性，因为其保证了在并发状态下数据库的稳定运行，而不会出现不同的事务进行干扰，造成数据库中的数据出现紊乱的情况。而隔离性的实现则是通过InnoDB引擎所独有的MVCC+锁的重要工具来进行实现。

**由于隔离性对于数据库事务的理解十分重要，下面开始重点介绍数据库的各种隔离特性**

------

### 2.**事务隔离级别**

1. **READ UNCOMMITTED（未提交读）**

   顾名思义，就是没有对事务进行提交，就将数据库中的内容进行修改，并且其他事务是可见的，由于其他事务对数据进行修改后对本事务是可见的所以也被称之为**脏读**。

2. **READ COMMIT（提交读）**

   也就是一个事务提交后，才可以读取其提交的数据，如果没有提交，是无法对其数据进行读取的。

   但是这同样会出现一个问题：**不可重复读**，一个事务中读取的两个数据可能出现不相同的情况。

3. **REPEATABLE READ（可重复读）**

   虽然可重复读解决了脏读的问题，同时也解决了两次读取的不相同的情况，但是还是会产生幻读的情况。出现幻读的情况主要是因为新插进来的数据没办法限制。如果一个事务查询一个数据之后，会为查询到的行都添加一个悲观锁，所以这些数据都没有办法被删除或者修改，但是无法限制新添加进来的数据，如果新来的数据符合这个集合的要求，则会出现**幻读**，凭空多出来的数据。

   **注意：**在InnoDB数据库引擎中采用了间隙锁(next-key locking) 策略防止幻读的产生，也就是将之前读取的数据行之间的间隔也进行了锁定，防止了幻影行的插入。

4. **SERIALIZABLE（可串行化）**

   **SERIALIZABLE**是最高的隔离级别，不会出现以上的所有情况是因为开启了事务的串行化，也就是会在每行数据上都进行加锁操作，只有在确定数据一致性以及可以接受没有并发的情况下才使用这个隔离级别。

   

**隔离级别的排序：**

![排序](innoDB中的事务.assets/640)

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | √    | √          | √    |
| 读已提交 | ×    | √          | √    |
| 可重复读 | ×    | ×          | √    |
| 串行化   | ×    | ×          | ×    |

### :star: ​3.事务隔离实现机制  

由先前对事务的**隔离性**的介绍可以得知：

隔离性通过**InnoDB**的**MVCC+锁**来进行控制，主要来避免**不可重复读**和**幻读**

如果您对Mysql在可重复读的过程中如何进行隔离存在疑问，可以观看以下这篇文章： [可重复读的细致理解](可重复读的细致理解.md) 

------

**事务隔离机制主要依赖以下的几个概念**： 

- **当前读和快照读**
- **undo log**
- **Read View 视图**

-------

#### 当前读和快照读

> 在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?

- **当前读**

像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁

- **快照读**

像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

> 说白了**MVCC就是为了实现读-写冲突不加锁**，而这个读指的就是**快照读**, 而非当前读，当**前读实际上是一种加锁的操作，是悲观锁的实现**

-------

#### 隐式字段

**DB_ROW_ID** 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引

**DB_TRX_ID** 6byte, 最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID

**DB_ROLL_PTR** 7byte, 回滚指针，指向这条记录的上一个版本（存储于rollback segment里）

**DELETED_BIT** 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了

------

#### Undo log

innodb中将用于回滚的日志称之为undo log。undo log是关于增删改相关的日志，而不会包含select中的日志。因为查找操作不会改变日志的版本号，而其他的三个操作会对版本号进行修改。

**Insert undo log** ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。

**Update undo log**：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。

**Delete undo log**：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。

- 删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。
- 为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。

------

#### read view（读视图）

> read view在是数据库操作中对于快照读中所生成的一个数据结构模式，其中按照**事务ID**的大小保留着当前还存活的事务，在进行快照读的过程中会参考这些事务来返回查询的结果。

read view存在一个比较算法，是来进行可见性判断的，将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出**Undo Log**中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本。

**read view主要存在三个主要信息**

- **up_limit_id** 记录trx_list列表中事务ID最小的ID
- **low_limit_id** ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1
- **trx_list** 未提交事务ID列表，用来维护Read View生成时刻系统正活跃的事务ID

**判断算法：**

> 如果id > low_limit_id,那么不可显示，如果id < up_limit_id则可以显示，剩下在trx_list中进行判断，如果在list中则不可显示，如果不在则显示出来。这里的显示是指可以被读取。

**而不同隔离级别的情况下read view生成的时机不同：**

- 在提交读的情况下，每次进行快照读时生成 read view
- 在不可重复读的条件下，在第一次进行快照读的时候生成 read view

------

### 4.总结

事务的四大特性是原子性、一致性、隔离性、持久性，其中最为重要的是隔离性。

当多个事务并发执行的时候，会引发脏读、不可重复读、幻读这些问题，那为了避免这些问题，SQL 提出了四种隔离级别，分别是读未提交、读已提交、可重复读、串行化，从左往右隔离级别顺序递增，隔离级别越高，意味着性能越差，InnoDB 引擎的默认隔离级别是可重复读。

事务隔离主要是通过undo log和read view来进行实现的，通过得到read view和回滚指针回退到undo log中。在进行快照读时，则可通过数据的可见性读取到事务所见的数据。

希望通过以上的介绍，可以对数据库的事务进行一定的了解，**欢迎star**

