# 聚合

## 1.聚合的模板

在[db.collection.aggregate]方法中，管道阶段出现在数组中。文档按顺序通过各个阶段。除$out, $merge和$geoNear阶段之外的所有阶段都可以在管道中多次出现。



```
db.collection.aggregate( [ { <stage> }, ... ] )
```

下面是可以在aggregate中加入的阶段，聚合是分阶段进行的。

| 阶段                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| [$addFields]()      | 向文档添加新字段。类似于[$project]()，[$addFields]()重塑了流中的每个文档;具体而言，通过向输出文档添加新字段，该文档包含输入文档和新添加字段中的现有字段。 [`$set`]()是[`$addFields`]()的别名。 |
| [$bucket]()         | 根据指定的表达式和存储区边界，将传入的文档分组，称为bucket。 |
| [$bucketAuto]()     | 根据指定的表达式将传入的文档分类为特定数量的组(称为bucket)。自动确定bucket边界，以便将文档均匀地分配到指定数量的bucket中。 |
| [$collStats]()      | 返回有关集合或视图的统计信息。                               |
| [$count]()          | 返回聚合管道此阶段的文档数量计数。                           |
| [$facet]()          | 在同一组输入文档的单个阶段内处理多个[聚合管道]()。允许创建能够在单个阶段中跨多个维度或方面描述数据的多面聚合。 |
| [$geoNear]()        | 根据与地理空间点的接近程度返回一个有序的文档流。将[$match]()，[$sort]()和[$limit]()的功能合并到地理空间数据中。输出文档包括附加距离字段，并且可以包括位置标识符字段。 |
| [$graphLookup]()    | 对集合执行递归搜索。对于每个输出文档，添加一个新的数组字段，该字段包含该文档的递归搜索的遍历结果。 |
| [$group]()          | 按指定的标识符表达式对文档进行分组，并将累加器表达式(如果指定)应用于每个组。使用所有输入文档并为每个不同的组输出一个文档。输出文档只包含标识符字段和累积字段(如果指定的话)。 |
| [$indexStats]()     | 返回有关集合的每个索引的使用情况的统计信息。                 |
| [$limit]()          | 将未修改的前 n 个文档传递给管道，其中 n 是指定的限制。对于每个输入文档，输出一个文档(对于前 n 个文档)或零文档(在前 n 个文档之后)。 |
| [$listSessions]()   | 列出足以传播到`system.sessions`集合的所有会话。              |
| [$lookup]()         | 对同一数据库中的另一个集合执行左外连接，从“已连接”集合中过滤文档以进行处理。 |
| [$match]()          | 过滤文档流以仅允许匹配的文档未经修改地传递到下一个管道阶段。 [$match]()使用标准的 MongoDB 查询。对于每个输入文档，输出一个文档(匹配)或零文档(不匹配)。 |
| [$merge]()          | 将聚合管道的结果文档写入集合。这个阶段可以将结果合并到一个输出集合中(插入新文档、合并文档、替换文档、保留现有文档、操作失败、使用自定义更新管道处理文档)。要使用[`$merge`]()阶段，它必须是管道中的最后一个阶段。 version 4.2 中的新功能 |
| [$out]()            | 将聚合管道的结果文档写入集合。要使用[$out]()阶段，它必须是管道中的最后一个阶段。 |
| [$planCacheStats]() | 返回集合的计划缓存信息。                                     |
| [$project]()        | 重新整形流中的每个文档，例如添加新字段或删除现有字段。对于每个输入文档，输出一个文档。 有关删除现有字段，请参见[`$unset`]()。 |
| [$redact]()         | 通过基于文档本身中存储的信息限制每个文档的内容来重塑流中的每个文档。合并[$project]()和[$match]()的功能。可用于实现字段级修订。对于每个输入文档，输出一个或零个文档。 |
| [$replaceRoot]()    | 用指定的嵌入文档替换文档。该操作将替换输入文档中的所有现有字段，包括`_id`字段。指定嵌入在输入文档中的文档，以将嵌入的文档提升到顶层。 [`$replaceWith`]()是[`$replaceRoot`]()阶段的别名。 |
| [$replaceWith]()    | 用指定的嵌入文档替换文档。该操作将替换输入文档中的所有现有字段，包括`_id`字段。指定嵌入在输入文档中的文档，以将嵌入的文档提升到顶层。 [`$replaceWith`]()是[`$replaceRoot`]()阶段的别名。 |
| [$sample]()         | 从输入中随机选择指定数量的文档。                             |
| [$set]()            | 向文档添加新字段。与[`$project`]()类似，[`$set`]()会重新塑造流中的每个文档；具体来说，通过向包含输入文档中的现有字段和新添加字段的输出文档添加新字段。 [`$set`]()是[`$addFields`]()阶段的别名。 |
| [$skip]()           | 跳过前 n 个文档，其中 n 是指定的跳过编号，并将其余未修改的文档传递给管道。对于每个输入文档，输出零文档(对于前 n 个文档)或一个文档(如果在前 n 个文档之后)。 |
| [$sort]()           | 按指定的排序键重新排序文档。只有顺序改变;文件保持不变。对于每个输入文档，输出一个文档。 |
| [$sortByCount]()    | 根据指定表达式的值对传入文档进行分组，然后计算每个不同组中的文档计数。 |
| [$unionWith]()      | 执行两个集合的并集;例如，将来自两个集合的管道结果组合成一个结果集。 version 4.4 中的新功能 |
| [$unset]()          | 从文档中移除/排除字段。 [`$unset`]()是移除字段阶段的[`$project stage`]()的别名。 |
| [$unwind]()         | 解析输入文档中的数组字段，为每个元素输出一个文档。每个输出文档用一个元素值替换数组。对于每个输入文档，输出n个文档，其中n是数组元素的数量，对于空数组可以为零。 |

## 2.模板的具体使用

```js
db.course.insert({name:"张三",age:10,grade:"四年级",course:["数学","英语","政治"]})
db.course.insert({name:"李四",age:9,grade:"三年级",course:["数学","语文","自然"]})
db.course.insert({name:"王五",age:11,grade:"四年级",course:["数学","英语","语文"]})
db.course.insert({name:"赵六",age:9,grade:"四年级",course:["数学","历史","政治"]})
```

- `$group`

按指定的标识符表达式对文档进行分组，并将累加器表达式(如果指定)应用于每个组。使用所有输入文档并为每个不同的组输出一个文档。输出文档只包含标识符字段和累积字段(如果指定的话)。

相当于sql语句中的group by，将所有的文件按照系列进行分组

```
db.course.aggregate(
   [
     {
     $group: {
       _id: "$grade",
       names:{$addToSet :"$name"}
       }
     }
   ]
)
---
[
  {
    "_id": "三年级",
    "names": [
      "李四"
    ]
  },
  {
    "_id": "四年级",
    "names": [
      "王五",
      "张三",
      "赵六"
    ]
  }
]
```



- `unwind`

将数组进行拆分，得到数组长度个数的文档，一般用于数组中元素的统计

- `$sort`

就是按照某个元素来进行排序，如果存在多个，则按照多个元素来进行排序

```js
db.course.aggregate(
   [
     { $unwind: "$course" },
     { $group: { _id: "$course", sum: { $sum: 1 }} },
     { $sort: { sum: -1} }
   ]
)
[
  {
    "_id": "数学",
    "sum": 4
  },
  {
    "_id": "英语",
    "sum": 2
  },
  {
    "_id": "语文",
    "sum": 2
  },
  {
    "_id": "政治",
    "sum": 2
  },
  {
    "_id": "自然",
    "sum": 1
  },
  {
    "_id": "历史",
    "sum": 1
  }
]
```

- `$match`

match就相当于查询中的判断条件，在判断之后再进行分组

