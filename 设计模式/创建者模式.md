# 创建者模式

设计模式分为三种类型，共23种：

- **创建型模式**：[单例模式](https://github.com/youlookwhat/DesignPattern#3-单例设计模式)、[抽象工厂模式](https://github.com/youlookwhat/DesignPattern#2-工厂模式)、[建造者模式](https://github.com/youlookwhat/DesignPattern#11-建造者模式)、[工厂模式](https://github.com/youlookwhat/DesignPattern#2-工厂模式)、[原型模式](https://github.com/youlookwhat/DesignPattern#12-原型模式)。
- **结构型模式**：[适配器模式](https://github.com/youlookwhat/DesignPattern#5-适配器模式)、[桥接模式](https://github.com/youlookwhat/DesignPattern#15-桥接模式)、[装饰模式](https://github.com/youlookwhat/DesignPattern#7-装饰者模式)、[组合模式](https://github.com/youlookwhat/DesignPattern#16-组合模式)、[外观模式](https://github.com/youlookwhat/DesignPattern#8-外观模式)、[享元模式](https://github.com/youlookwhat/DesignPattern#13-享元模式)、[代理模式](https://github.com/youlookwhat/DesignPattern#14-代理模式)。
- **行为型模式**：[模版方法模式](https://github.com/youlookwhat/DesignPattern#9-模板方法模式)、[命令模式](https://github.com/youlookwhat/DesignPattern#6-命令模式)、[迭代器模式](https://github.com/youlookwhat/DesignPattern#17-迭代器模式)、[观察者模式](https://github.com/youlookwhat/DesignPattern#1-观察者模式)、[中介者模式](https://github.com/youlookwhat/DesignPattern#18-中介者模式)、[备忘录模式](https://github.com/youlookwhat/DesignPattern#19-备忘录模式)、[解释器模式](https://github.com/youlookwhat/DesignPattern#20-解释器模式)、[状态模式](https://github.com/youlookwhat/DesignPattern#10-状态模式)、[策略模式](https://github.com/youlookwhat/DesignPattern#4-策略模式)、[责任链模式](https://github.com/youlookwhat/DesignPattern#21-责任链模式)、[访问者模式](https://github.com/youlookwhat/DesignPattern#22-访问者模式)。

## 1.单例模式

单例模式就是保证一个类仅仅存在一个实例。如果存在多个实例，那么会对性能造成影响，并且多个实例在进行的过程中容易出现错误。

保证对象的唯一性：

1. 不允许其它程序使用new
2. 在本类中创建对象
3. 定义一个公开方法返回这个对象

- ### 饿汉式

```java
/**
 * 饿汉式写法
 * 在类在加载的过程中就生成了一个实例对象
 */
public class SingletonHunger {
    private SingletonHunger(){
    }
    private static SingletonHunger singletonHunger = new SingletonHunger();

    public SingletonHunger getInstance(){
        return singletonHunger;
    }
}
```

- ### 懒汉式

懒汉式就是在第一次使用实例对象的时候再对实例进行生成。

可以有效的对资源进行平均分配。

```java
public class SingletonLazy {
    private SingletonLazy(){}

    /**
     * 懒汉式的单线程写法，很明显线程不安全，在多个线程同时进行获取的时候，可能会出现多个实例
     */
    private static SingletonLazy singletonLazyOne = null;
    public SingletonLazy getSingletonLazyOne(){
        if(singletonLazyOne == null){
            singletonLazyOne = new SingletonLazy();
        }
        return singletonLazyOne;
    }

    /**
     * 虽然保证了线程的安全，但是会存在多个线程同时对实例进行获取的时候会出现阻塞的情况，导致性能大打折扣
     */
    private static SingletonLazy singletonLazyTwo = null;
    public synchronized SingletonLazy getSingletonLazyTwo(){
        if(singletonLazyTwo == null){
            singletonLazyTwo = new SingletonLazy();
        }
        return singletonLazyTwo;
    }

    /**
     * 虽然在这种情况下开起来是线程安全的，但是在实际执行的时候，在前一个类进入后，后一个类也进入了if语句，
     * 还是可能会生成多个实例对象
     */
    private static SingletonLazy singletonLazyThree = null;
    public synchronized SingletonLazy getSingletonLazyThree(){
        if(singletonLazyThree == null){
            synchronized (SingletonLazy.class){
                singletonLazyThree = new SingletonLazy();
            }
        }
        return singletonLazyThree;
    }

    /**
     * 最后一个也是最为推荐构建的饿汉式单例
     * 通过双重校验锁来进行实现,就是在锁之前和之后两次判断是否为null即可
     */
    private static SingletonLazy singletonLazyFour = null;
    public synchronized SingletonLazy getSingletonLazyFour(){
        if(singletonLazyFour == null){
            synchronized (SingletonLazy.class){
                if(singletonLazyFour == null){
                    singletonLazyFour = new SingletonLazy();
                }
            }
        }
        return singletonLazyFour;
    }
}
```

- ### 内部类

内部类的实现和饿汉式有着异曲同工之妙，但是其并不是在装在过程中生成实例对象，而是在第一次获取时对实例对象进行生成。

- ### 枚举

```java
public enum SingletonEnum {
    instance;

    private SingletonEnum(){}

    public void whatever(){

    }

    // 通过SingletonEnum.instance.method();来进行获取
}
```