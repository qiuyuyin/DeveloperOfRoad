## Pod

Pod是K8S中一个非常之重要的概念，通过Pod我们可以将一个实际主机看作一个虚拟主机进行实现，在整个Kubernentes集群中实现与实际主机的无相关性。可能你会觉得这个定义十分的绕口，但是通过将多个容器部署在一个Pod中，可以解决各个服务的耦合性同时使多个环境在各个主机上实现没有任何障碍的沟通，无需NAT服务而是直接使用各个Pod的IP地址来进行访问。

将应用服务部署在多个Pod环境中，由于应用的分层效率不同，在将Pod服务进行扩容的时候，是基于Pod来进行扩容，来转换为多个Pod来进行访问，所以假如一个应用存在前台和后台系统，我们应该将前台服务和后台服务分别部署在不同的Pod中，方便更细粒度的进行操作。

### Pod-label

在使用Pod的同时，Kubernetes很贴心的给我们准备了一个方式来区分不同的Pod，这就是label系统，使用label系统，可以区分每个Pod的状态，比如`app`来表示不同Pod的功能区别，`rel`可以区别不同label的版本号，同时可以使用自定义的标签来进行实现。

下面是基于命令来对不同标签进行访问：

查看pods的标签

```sh
kubectl get po --show-labels
```

查看带有creation,env的标签，使用-L来进行寻找：

```sh
kubectl get po -L creation_method,env
```

如果想要在一个Pod上添加标签：

```sh
kubecl label po kubia-manual creation_method=manual
```

但是如果想要对标签进行重写的话，则需要在后面添加一个--overwrite

### Pod-容错机制

当我们将容器部署在Pod之后，如果当服务出现错误比如访问量激增服务器无法承受压力导致服务宕机。虽然现实情况远远比这个要复杂的多，但是如果一个Pod中的容器出现问题之后，Kubernetes可以快速的将服务进行重新启动，在容器的新版本迭代中也可以看见，可以顺畅的将服务器升级（当然都是运维的活，不过Kubernetes的出现就是为了减少运维人员的压力）

**存活探针**

Kubernetes可以使用存活探针来对容器进行检测是否存活：

-   部署一个health服务，通过http的get方法对服务器进行访问，如果得到一个正确的服务则表示这个容器是没有任何问题的
-   使用更为底层的TCP套接字和容器的TCP进行连接，如果连接成功则表示容器存活
-   Exec探针在容器中执行命令，检查命令的退出状态码。如果状态码为0则表示成功。

